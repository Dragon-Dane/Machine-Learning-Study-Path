<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Regex introduction | Virgilio</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Data Science E-Learning">
    
    <link rel="preload" href="/Virgilio/assets/css/0.styles.0d4ec8ac.css" as="style"><link rel="preload" href="/Virgilio/assets/js/app.3bb05fb7.js" as="script"><link rel="preload" href="/Virgilio/assets/js/2.ce33443b.js" as="script"><link rel="preload" href="/Virgilio/assets/js/24.5e2c1541.js" as="script"><link rel="prefetch" href="/Virgilio/assets/js/10.ac90fcaa.js"><link rel="prefetch" href="/Virgilio/assets/js/11.6d7630f8.js"><link rel="prefetch" href="/Virgilio/assets/js/12.7c07bb9e.js"><link rel="prefetch" href="/Virgilio/assets/js/13.4aaf85be.js"><link rel="prefetch" href="/Virgilio/assets/js/14.794b82b5.js"><link rel="prefetch" href="/Virgilio/assets/js/15.de0d2908.js"><link rel="prefetch" href="/Virgilio/assets/js/16.a2d0700b.js"><link rel="prefetch" href="/Virgilio/assets/js/17.c2093d6f.js"><link rel="prefetch" href="/Virgilio/assets/js/18.6476b5c1.js"><link rel="prefetch" href="/Virgilio/assets/js/19.456bc232.js"><link rel="prefetch" href="/Virgilio/assets/js/20.a5c7c24b.js"><link rel="prefetch" href="/Virgilio/assets/js/21.302b1d43.js"><link rel="prefetch" href="/Virgilio/assets/js/22.57c0ffc7.js"><link rel="prefetch" href="/Virgilio/assets/js/23.fc9caeaa.js"><link rel="prefetch" href="/Virgilio/assets/js/25.6146a2f3.js"><link rel="prefetch" href="/Virgilio/assets/js/26.89ed9320.js"><link rel="prefetch" href="/Virgilio/assets/js/27.609b77e2.js"><link rel="prefetch" href="/Virgilio/assets/js/28.48aee5bc.js"><link rel="prefetch" href="/Virgilio/assets/js/29.e2413db2.js"><link rel="prefetch" href="/Virgilio/assets/js/3.3cd3ab8d.js"><link rel="prefetch" href="/Virgilio/assets/js/30.a8b0add2.js"><link rel="prefetch" href="/Virgilio/assets/js/31.c7c00d88.js"><link rel="prefetch" href="/Virgilio/assets/js/32.47c1b625.js"><link rel="prefetch" href="/Virgilio/assets/js/33.2f3cef5b.js"><link rel="prefetch" href="/Virgilio/assets/js/34.5ab82bbc.js"><link rel="prefetch" href="/Virgilio/assets/js/35.e1dbfb2f.js"><link rel="prefetch" href="/Virgilio/assets/js/36.7cda9382.js"><link rel="prefetch" href="/Virgilio/assets/js/37.9e9afb49.js"><link rel="prefetch" href="/Virgilio/assets/js/38.f1d5198e.js"><link rel="prefetch" href="/Virgilio/assets/js/39.559fd0ec.js"><link rel="prefetch" href="/Virgilio/assets/js/4.06abc881.js"><link rel="prefetch" href="/Virgilio/assets/js/40.ef457ea0.js"><link rel="prefetch" href="/Virgilio/assets/js/41.bb9fe278.js"><link rel="prefetch" href="/Virgilio/assets/js/42.fac2df41.js"><link rel="prefetch" href="/Virgilio/assets/js/43.36295d12.js"><link rel="prefetch" href="/Virgilio/assets/js/44.14bdd56e.js"><link rel="prefetch" href="/Virgilio/assets/js/45.3bd3044d.js"><link rel="prefetch" href="/Virgilio/assets/js/46.ef34bace.js"><link rel="prefetch" href="/Virgilio/assets/js/47.538d5308.js"><link rel="prefetch" href="/Virgilio/assets/js/48.57528e4f.js"><link rel="prefetch" href="/Virgilio/assets/js/49.d9e20831.js"><link rel="prefetch" href="/Virgilio/assets/js/5.227f41b1.js"><link rel="prefetch" href="/Virgilio/assets/js/50.7e8319c0.js"><link rel="prefetch" href="/Virgilio/assets/js/6.87933338.js"><link rel="prefetch" href="/Virgilio/assets/js/7.dd610a50.js"><link rel="prefetch" href="/Virgilio/assets/js/8.983ea529.js"><link rel="prefetch" href="/Virgilio/assets/js/9.8f8af7b0.js">
    <link rel="stylesheet" href="/Virgilio/assets/css/0.styles.0d4ec8ac.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Virgilio/" class="home-link router-link-active"><!----> <span class="site-name">Virgilio <span class="site-name2"> Data Science </span></span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/virgili0/Virgilio" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Contribute
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/virgili0/Virgilio" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Contribute
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Virgilio/" aria-current="page" class="sidebar-link">What is Virgilio?</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Paradiso</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/paradiso/demystification-ai-ml-dl.html" class="sidebar-link">Demystification of the key concepts of AI and ML</a></li><li><a href="/Virgilio/paradiso/what-do-i-need-for-ml.html" class="sidebar-link">What do I need to do Machine Learning?</a></li><li><a href="/Virgilio/paradiso/do-you-really-need-ml.html" class="sidebar-link">Do you really need Machine Learning?</a></li><li><a href="/Virgilio/paradiso/use-cases.html" class="sidebar-link">Machine Learning use cases</a></li><li><a href="/Virgilio/paradiso/virgilio-teaching-strategy.html" class="sidebar-link">Virgilio's Teaching Strategy</a></li><li><a href="/Virgilio/paradiso/introduction-to-ml.html" class="sidebar-link">Introduction to Machine Learning</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Purgatorio</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>Fundamentals</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/purgatorio/fundamentals/math-fundamentals.html" class="sidebar-link">Mathematics</a></li><li><a href="/Virgilio/purgatorio/fundamentals/statistics-fundamentals.html" class="sidebar-link">Statistics</a></li><li><a href="/Virgilio/purgatorio/fundamentals/python-fundamentals.html" class="sidebar-link">Python</a></li><li><a href="/Virgilio/purgatorio/fundamentals/jupyter-notebook.html" class="sidebar-link">Jupyter Notebook</a></li><li><a href="/Virgilio/purgatorio/fundamentals/the-data-science-process.html" class="sidebar-link">The Data Science Process</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Define The Scope and Ask Questions</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/purgatorio/define-the-scope-and-ask-questions/frame-the-problem.html" class="sidebar-link">Frame the Problem</a></li><li><a href="/Virgilio/purgatorio/define-the-scope-and-ask-questions/usage-and-integration.html" class="sidebar-link">Usage and Integration</a></li><li><a href="/Virgilio/purgatorio/define-the-scope-and-ask-questions/starting-a-data-project.html" class="sidebar-link">Starting a Data Project</a></li><li><a href="/Virgilio/purgatorio/define-the-scope-and-ask-questions/workspace-setup-and-cloud-computing.html" class="sidebar-link">Workspace Setup and Cloud Computing</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Collect and Prepare Data</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/purgatorio/collect-and-prepare-data/data-collection.html" class="sidebar-link">Data Collection</a></li><li><a href="/Virgilio/purgatorio/collect-and-prepare-data/data-preparation.html" class="sidebar-link">Data Preparation</a></li><li><a href="/Virgilio/purgatorio/collect-and-prepare-data/data-visualization.html" class="sidebar-link">Data Visualization</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Select and Train Machine Learning Models</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/purgatorio/select-and-train-machine-learning-models/machine-learning-theory.html" class="sidebar-link">Machine Learning Theory</a></li><li><a href="/Virgilio/purgatorio/select-and-train-machine-learning-models/deep-learning-theory.html" class="sidebar-link">Deep Learning Theory</a></li><li><a href="/Virgilio/purgatorio/select-and-train-machine-learning-models/evaluation-and-finetuning.html" class="sidebar-link">Evaluation and Fine Tuning</a></li><li><a href="/Virgilio/purgatorio/select-and-train-machine-learning-models/tools-and-libraries.html" class="sidebar-link">Tools and Libraries</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Launch and Mantain the System </span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/purgatorio/launch-and-mantain-the-system/serving-trained-models.html" class="sidebar-link">Serving Trained Models</a></li><li><a href="/Virgilio/purgatorio/launch-and-mantain-the-system/monitoring-usage-and-behavior.html" class="sidebar-link">Monitoring Usage and Behavior</a></li><li><a href="/Virgilio/purgatorio/launch-and-mantain-the-system/automation-and-reproducibility.html" class="sidebar-link">Automation and Reproducibility</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Now Go Build </span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/purgatorio/now-go-build/a-messy-real-world.html" class="sidebar-link">A Messy Real World</a></li><li><a href="/Virgilio/purgatorio/now-go-build/transfer-learning.html" class="sidebar-link">Transfer Learning</a></li><li><a href="/Virgilio/purgatorio/now-go-build/best-practices.html" class="sidebar-link">Best Practices</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Inferno</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Welcome to Inferno</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/inferno/welcome-to-inferno/welcome-to-inferno.html" class="sidebar-link">Welcome to Inferno</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Time Series</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/inferno/time-series/introduction-to-time-series.html" class="sidebar-link">Introduction to Time Series</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Computer Vision</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/inferno/computer-vision/introduction-to-computer-vision.html" class="sidebar-link">Introduction to Computer Vision using OpenCV and Python</a></li><li><a href="/Virgilio/inferno/computer-vision/object-instance-segmentation.html" class="sidebar-link">Object Instance Segmentation using TensorFlow Framework and Cloud GPU Technology</a></li><li><a href="/Virgilio/inferno/computer-vision/object-tracking.html" class="sidebar-link">Object Tracking based on Deep Learning</a></li><li><a href="/Virgilio/inferno/computer-vision/Object_detection_based_on_Deep_Learning.html" class="sidebar-link">Object detection based on Deep Learning</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Soft Skills</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/inferno/soft-skills/impactful-presentations.html" class="sidebar-link">Impactful Presentations</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>Tools</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/inferno/tools/geo-gebra.html" class="sidebar-link">Geo Gebra</a></li><li><a href="/Virgilio/inferno/tools/latex.html" class="sidebar-link">LaTex</a></li><li><a href="/Virgilio/inferno/tools/regex.html" aria-current="page" class="active sidebar-link">Regex introduction</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Virgilio/inferno/tools/regex.html#what-is-a-regex" class="sidebar-link">What is a regex?</a></li><li class="sidebar-sub-header"><a href="/Virgilio/inferno/tools/regex.html#why-do-regular-expressions-matter" class="sidebar-link">Why do regular expressions matter?</a></li><li class="sidebar-sub-header"><a href="/Virgilio/inferno/tools/regex.html#prerequisites" class="sidebar-link">Prerequisites</a></li><li class="sidebar-sub-header"><a href="/Virgilio/inferno/tools/regex.html#basic-regex" class="sidebar-link">Basic regex</a></li><li class="sidebar-sub-header"><a href="/Virgilio/inferno/tools/regex.html#matching-options" class="sidebar-link">Matching options</a></li><li class="sidebar-sub-header"><a href="/Virgilio/inferno/tools/regex.html#matching-repetitions" class="sidebar-link">Matching repetitions</a></li><li class="sidebar-sub-header"><a href="/Virgilio/inferno/tools/regex.html#character-classes" class="sidebar-link">Character classes</a></li><li class="sidebar-sub-header"><a href="/Virgilio/inferno/tools/regex.html#more-re-functions" class="sidebar-link">More re functions</a></li><li class="sidebar-sub-header"><a href="/Virgilio/inferno/tools/regex.html#special-characters" class="sidebar-link">Special characters</a></li><li class="sidebar-sub-header"><a href="/Virgilio/inferno/tools/regex.html#groups" class="sidebar-link">Groups</a></li><li class="sidebar-sub-header"><a href="/Virgilio/inferno/tools/regex.html#toy-project-about-regex" class="sidebar-link">Toy project about regex</a></li><li class="sidebar-sub-header"><a href="/Virgilio/inferno/tools/regex.html#further-reading" class="sidebar-link">Further reading</a></li></ul></li><li><a href="/Virgilio/inferno/tools/wolfram-alpha.html" class="sidebar-link">Wolfram Alpha</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Research</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Virgilio/inferno/research/zotero.html" class="sidebar-link">Zotero</a></li><li><a href="/Virgilio/inferno/research/sota-papers.html" class="sidebar-link">Research papers explained</a></li></ul></section></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="regex-introduction"><a href="#regex-introduction" class="header-anchor">#</a> Regex introduction</h1> <h2 id="what-is-a-regex"><a href="#what-is-a-regex" class="header-anchor">#</a> What is a regex?</h2> <p><a href="https://en.wikipedia.org/wiki/Regular_expression" target="_blank" rel="noopener noreferrer"><strong>Regex</strong><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> stands for <em>regular expression</em>, and regular expressions are a way of writing patterns that match strings. Usually these patterns can be used to search strings for specific things, or to search and then replace certain things, etc. Regular expressions are great for string manipulation!</p> <h2 id="why-do-regular-expressions-matter"><a href="#why-do-regular-expressions-matter" class="header-anchor">#</a> Why do regular expressions matter?</h2> <p>From the first paragraph in this guide you might have guessed it, but regular expressions can be very useful <strong>whenever you have to deal with strings</strong>. From the basic renaming of a set of similarly named variables in your source code to <a href="https://github.com/clone95/Virgilio/blob/master/Specializations/HardSkills/DataPreprocessing.md" target="_blank" rel="noopener noreferrer">data preprocessing<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. Regular expressions usually offer a concise way of expressing whatever type of things you want to find. For example, if you wanted to parse a form and look for the year that someone might have been born in, you could use something like <code>(19)|(20)[0-9][0-9]</code>. This is an example of a regular expression!</p> <h2 id="prerequisites"><a href="#prerequisites" class="header-anchor">#</a> Prerequisites</h2> <p>This guide does not assume any prior knowledge. Examples will be coded in Python, but mastery of the programming language is neither assumed nor needed. You are welcome to read the guide in your browser or to download it and to run the examples/toying around with them.</p> <h1 id="index"><a href="#index" class="header-anchor">#</a> Index</h1> <ul><li><a href="#Basic-regex">Basic regex</a> <ul><li><a href="#Using-Python-re">Using Python re</a></li> <li><a href="#$%5Cpi$-lookup">$\pi$ lookup</a></li></ul></li> <li><a href="#Matching-options">Matching options</a> <ul><li><a href="#Virgilio-or-Virgil?">Virgilio or Virgil?</a></li></ul></li> <li><a href="#Matching-repetitions">Matching repetitions</a> <ul><li><a href="#Greed">Greed</a></li> <li><a href="#Removing-excessive-spaces">Removing excessive spaces</a></li></ul></li> <li><a href="#Character-classes">Character classes</a> <ul><li><a href="#Phone-numbers-v1">Phone numbers v1</a></li></ul></li> <li><a href="#More-re-functions">More <code>re</code> functions</a> <ul><li><a href="#search-with-match"><code>search</code> with <code>match</code></a></li> <li><a href="#Count-matches-with-findall">Count matches with <code>findall</code></a></li></ul></li> <li><a href="#Special-characters">Special characters</a> <ul><li><a href="#Phone-numbers-v2">Phone numbers v2</a></li></ul></li> <li><a href="#Groups">Groups</a> <ul><li><a href="#Phone-numbers-v3">Phone numbers v3</a></li></ul></li> <li><a href="#Toy-project-about-regex">Toy project about regex</a></li> <li><a href="#Further-reading">Further reading</a></li> <li><a href="#Suggested-solutions">Suggested solutions</a></li></ul> <p>Let's dive right in!</p> <p><strong>Just a quick word:</strong> I tried to include some small exercises whenever I show you something new, so that you can try and test your knowledge. Examples of solutions are provided in the <a href="#Suggested-solutions">end of the notebook</a>.</p> <h2 id="basic-regex"><a href="#basic-regex" class="header-anchor">#</a> Basic regex</h2> <p>A regex is just a string written in a certain format, that can then be used by specific tools/libraries/programs to perform pattern matching on strings. Throughout this guide we will use <code>this formatting</code> to refer to regular expressions!</p> <p>The simplest regular expressions that one can create are just composed of regular characters. If you wanted to find all the occurrences of the word <em>&quot;Virgilio&quot;</em> in a text, you could write the regex <code>Virgilio</code>. In this regular expression, no character is doing anything special or different. In fact, this regular expression is just a normal word. That is ok, regular expressions are strings, after all!</p> <p>If you were given the text <em>&quot;Project Virgilio is great&quot;</em>, you could use your <code>Virgilio</code> regex to find the occurrence of the word <em>&quot;Virgilio&quot;</em>. However, if the text was <em>&quot;Project virgilio is great&quot;</em>, then your regex wouldn't work, because regular expressions are <strong>case-sensitive</strong> by default and thus should match everything exactly. We say that <code>Virgilio</code> matches the sequence of characters &quot;Virgilio&quot; literally.</p> <h3 id="using-python-re"><a href="#using-python-re" class="header-anchor">#</a> Using Python re</h3> <p>To check if our regular expressions are working well and to give you the opportunity to directly experiment with them, we will be using Python's <code>re</code> module to work with regular expressions. To use the <code>re</code> module we first import it, then define a regular expression and then use the <code>search()</code> function over a string! Pretty simple:</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">import</span> re

regex <span class="token operator">=</span> <span class="token string">&quot;Virgilio&quot;</span>
str1 <span class="token operator">=</span> <span class="token string">&quot;Project Virgilio is great&quot;</span>
str2 <span class="token operator">=</span> <span class="token string">&quot;Project virgilio is great&quot;</span>

<span class="token keyword">if</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;'{}' is in '{}'&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;'{}' is not in '{}'&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">)</span>
    
<span class="token keyword">if</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;'{}' is in '{}'&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;'{}' is not in '{}'&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>'Virgilio' is in 'Project Virgilio is great'
'Virgilio' is not in 'Project virgilio is great'
</code></pre></div><p>The <code>re.search(regex, string)</code> function takes a regex as first argument and then searches for any matches over the string that was given as the second argument. However, the return value of the function is <strong>not</strong> a boolean, but a <em>match object</em>:</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(8, 16), match='Virgilio'&gt;
</code></pre></div><p>Match objects have relevant information about the match(es) encountered: the start and end positions, the string that was matched, and even some other things for more complex regular expressions.</p> <p>We can see that in this case the match is exactly the same as the regular expression, so it may look like the <code>match</code> information inside the match object is irrelevant... but it becomes relevant as soon as we introduce options or repetitions into our regex.</p> <p>If no matches are found, then the <code>.search()</code> function returns <code>None</code>:</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>None
</code></pre></div><p>Whenever the match is not <code>None</code>, we can save the returned match object and use it to extract all the needed information!</p> <div class="language-python extra-class"><pre class="language-python"><code>m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> str1<span class="token punctuation">)</span>
<span class="token keyword">if</span> m <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;The match started at pos {} and ended at pos {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span>end<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Or with tuple notation, the match is at {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>span<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;And btw, the actual string matched was '{}'&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>The match started at pos 8 and ended at pos 16
Or with tuple notation, the match is at (8, 16)
And btw, the actual string matched was 'Virgilio'
</code></pre></div><p>Now you should try to get some more matches and some fails with your own literal regular expressions. I provide three examples of my own:</p> <div class="language-python extra-class"><pre class="language-python"><code>m1 <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">&quot;regex&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;This guide is about regexes&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> m1 <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;The match is at {}\n&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span>span<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

m2 <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;The alphabet goes 'abdefghij...'&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> m2 <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Woops, did I just got the alphabet wrong..?\n&quot;</span><span class="token punctuation">)</span>
    
s <span class="token operator">=</span> <span class="token string">&quot;aaaaa aaaaaa a aaa&quot;</span>
m3 <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span>
<span class="token keyword">if</span> m3 <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;I just matched '{}' inside '{}'&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>m3<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>The match is at (20, 25)

Woops, did I just got the alphabet wrong..?

I just matched 'a' inside 'aaaaa aaaaaa a aaa'
</code></pre></div><h3 id="pi-lookup"><a href="#pi-lookup" class="header-anchor">#</a> $\pi$ lookup</h3> <p>$$\pi = 3.1415\cdots$$</p> <p>right? Well, what comes after the dots? An infinite sequence of digits, right? Could it be that your date of birth appears in the first million digits of $\pi$? Well, we could use a regex to find that out! Change the <code>regex</code> variable below to look for your date of birth or for any number you want, in the first million digits of $\pi$!</p> <div class="language-python extra-class"><pre class="language-python"><code>pifile <span class="token operator">=</span> <span class="token string">&quot;regex-bin/pi.txt&quot;</span>
regex <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>  <span class="token comment"># define your regex to look your favourite number up</span>

<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>pifile<span class="token punctuation">,</span> <span class="token string">&quot;r&quot;</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    pistr <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># pistr is a string that contains 1M digits of pi</span>
    
<span class="token comment">## search for your number here</span>
</code></pre></div><p>To search for numbers in the first 100 million digits of $\pi$ (or 200 million, I didn't really get it) you can check <a href="https://www.angio.net/pi/piquery" target="_blank" rel="noopener noreferrer">this<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> website.</p> <h2 id="matching-options"><a href="#matching-options" class="header-anchor">#</a> Matching options</h2> <p>We just saw a very simple regular expression that was trying to find the word <em>&quot;Virgilio&quot;</em> in text, but we also saw that we had zero flexibility and we couldn't even handle the fact that someone may have forgotten to capitalize the name properly, spelling it like <em>&quot;virgilio&quot;</em> instead.</p> <p>To prevent problems like this, regular expressions can be written in a way to handle different possibilities. For our case, we want the first letter to be either <em>&quot;V&quot;</em> or <em>&quot;v&quot;</em>, and that should be followed by <em>&quot;irgilio&quot;</em>.</p> <p>In order to handle different possibilities, we use the character <code>|</code>. For instance, <code>V|v</code> matches the letter vee, regardless of its capitalization:</p> <div class="language-python extra-class"><pre class="language-python"><code>v <span class="token operator">=</span> <span class="token string">&quot;v&quot;</span>
V <span class="token operator">=</span> <span class="token string">&quot;V&quot;</span>
regex <span class="token operator">=</span> <span class="token string">&quot;v|V&quot;</span>
<span class="token keyword">if</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;small v found&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;big V found&quot;</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>small v found
big V found
</code></pre></div><p>Now we can concatenate the regex for the first letter and the <code>irgilio</code> regex (for the rest of the name) to get a regex that matches the name of Virgilio, regardless of the capitalization of its first letter:</p> <div class="language-python extra-class"><pre class="language-python"><code>virgilio <span class="token operator">=</span> <span class="token string">&quot;virgilio&quot;</span>
Virgilio <span class="token operator">=</span> <span class="token string">&quot;Virgilio&quot;</span>
regex <span class="token operator">=</span> <span class="token string">&quot;(V|v)irgilio&quot;</span>
<span class="token keyword">if</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> virgilio<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;virgilio found!&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> Virgilio<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Virgilio found!&quot;</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>virgilio found!
Virgilio found!
</code></pre></div><p>Notice that we write the regex with parenthesis: <code>(V|v)irgilio</code></p> <p>If we only wrote <code>V|virgilio</code>, then the regular expression would match either &quot;V&quot; or &quot;virgilio&quot;, instead of &quot;Virgilio&quot; or &quot;virgilio&quot;:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;V|virgilio&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;This sentence only has a big V&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(29, 30), match='V'&gt;
</code></pre></div><p>So we really need to parenthesize the <code>(V|v)</code> there. If we do, it will work as expected!</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;(V|v)irgilio&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;The name of the project is virgilio, but with a big V!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;This sentence only has a big V&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(27, 35), match='virgilio'&gt;
None
</code></pre></div><p>Maybe you didn't even notice, but there is something else going on! Notice that we used the characteres <code>|</code>, <code>(</code> and <code>)</code>, and those are not present in the word <em>&quot;virgilio&quot;</em>, but nonetheless our regex <code>(V|v)irgilio</code> matched it... that is because these three characters have special meanings in the regex world, and hence are <strong>not</strong> interpreted literally, contrary to what happens to any letter in <code>irgilio</code>.</p> <h3 id="virgilio-or-virgil"><a href="#virgilio-or-virgil" class="header-anchor">#</a> Virgilio or Virgil?</h3> <p>Here is a couple of paragraphs from Wikipedia's <a href="https://en.wikipedia.org/wiki/Virgil" target="_blank" rel="noopener noreferrer">article on Virgil<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>:</p> <blockquote><p>Publius Vergilius Maro (Classical Latin: [ˈpuː.blɪ.ʊs wɛrˈɡɪ.lɪ.ʊs ˈma.roː]; traditional dates October 15, 70 BC – September 21, 19 BC[1]), usually called Virgil or Vergil (/ˈvɜːrdʒɪl/) in English, was an ancient Roman poet of the Augustan period. He wrote three of the most famous poems in Latin literature: the Eclogues (or Bucolics), the Georgics, and the epic Aeneid. A number of minor poems, collected in the Appendix Vergiliana, are sometimes attributed to him.[2][3]</p></blockquote> <blockquote><p>Virgil is traditionally ranked as one of Rome's greatest poets. His Aeneid has been considered the national epic of ancient Rome since the time of its composition. Modeled after Homer's Iliad and Odyssey, the Aeneid follows the Trojan refugee Aeneas as he struggles to fulfill his destiny and reach Italy, where his descendants Romulus and Remus were to found the city of Rome. Virgil's work has had wide and deep influence on Western literature, most notably Dante's Divine Comedy, in which Virgil appears as Dante's guide through Hell and Purgatory.</p></blockquote> <p>&quot;Virgilio&quot; is the italian form of &quot;Virgil&quot;, and I edited the above paragraphs to have the italian version instead of the english one. I want you to revert this!</p> <p>You might want to take a look at <a href="https://realpython.com/python-while-loop/" target="_blank" rel="noopener noreferrer"><code>while</code> cycles in Python<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="https://www.digitalocean.com/community/tutorials/how-to-index-and-slice-strings-in-python-3" target="_blank" rel="noopener noreferrer">string indexing<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> and <a href="https://realpython.com/python-string-split-concatenate-join/" target="_blank" rel="noopener noreferrer">string concatenation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. The point is that you find a match, you break the string into the part <em>before</em> the match and the part <em>after</em> the match, and you glue those two together with <em>Virgilio</em> in between.</p> <p>Notice that <a href="https://www.tutorialspoint.com/python/string_replace.htm" target="_blank" rel="noopener noreferrer">string replacement<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> would probably be faster and easier, but that would defeat the purpose of this exercise. After fixing everything, print the final results to be sure that you fixed every occurrence of the name.</p> <div class="language-python extra-class"><pre class="language-python"><code>paragraphs <span class="token operator">=</span> \
<span class="token triple-quoted-string string">&quot;&quot;&quot;Publius Vergilius Maro (Classical Latin: [ˈpuː.blɪ.ʊs wɛrˈɡɪ.lɪ.ʊs ˈma.roː]; traditional dates October 15, 70 BC – September 21, 19 BC[1]), usually called virgilio or Vergil (/ˈvɜːrdʒɪl/) in English, was an ancient Roman poet of the Augustan period. He wrote three of the most famous poems in Latin literature: the Eclogues (or Bucolics), the Georgics, and the epic Aeneid. A number of minor poems, collected in the Appendix Vergiliana, are sometimes attributed to him.[2][3]

Virgilio is traditionally ranked as one of Rome's greatest poets. His Aeneid has been considered the national epic of ancient Rome since the time of its composition. Modeled after Homer's Iliad and Odyssey, the Aeneid follows the Trojan refugee Aeneas as he struggles to fulfill his destiny and reach Italy, where his descendants Romulus and Remus were to found the city of Rome. virgilio's work has had wide and deep influence on Western literature, most notably Dante's Divine Comedy, in which virgilio appears as Dante's guide through Hell and Purgatory.&quot;&quot;&quot;</span>
</code></pre></div><h2 id="matching-repetitions"><a href="#matching-repetitions" class="header-anchor">#</a> Matching repetitions</h2> <p>Sometimes we want to find patterns that have bits that will be repeated. For example, people make a <em>&quot;awww&quot;</em> or <em>&quot;owww&quot;</em> sound when they see something cute, like a baby. But the number of <em>&quot;w&quot;</em> I used there was completely arbitrary! If the baby is really really cute, someone might write <em>&quot;awwwwwwwwwww&quot;</em>. So how can I write a regex that matches <em>&quot;aww&quot;</em> and <em>&quot;oww&quot;</em>, but with an arbitrary number of characters <em>&quot;w&quot;</em>?</p> <p>I will illustrate several ways of capturing repetitions, by testing regular expressions against the following strings:</p> <ul><li>&quot;awww&quot; (3 letters &quot;w&quot;)</li> <li>&quot;awwww&quot; (4 letters &quot;w&quot;)</li> <li>&quot;awwwwwww&quot; (7 letters &quot;w&quot;)</li> <li>&quot;awwwwwwwwwwwwwwww&quot; (16 letters &quot;w&quot;)</li> <li>&quot;aw&quot; (1 letter &quot;w&quot;)</li> <li>&quot;a&quot; (0 letters &quot;w&quot;)</li></ul> <div class="language-python extra-class"><pre class="language-python"><code>cute_strings <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;awww&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;awwww&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;awwwwwww&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;awwwwwwwwwwwwwwww&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;aw&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;a&quot;</span>
<span class="token punctuation">]</span>

<span class="token keyword">def</span> <span class="token function">match_cute_strings</span><span class="token punctuation">(</span>regex<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;Takes a regex, prints matches and non-matches&quot;&quot;&quot;</span>
    <span class="token keyword">for</span> s <span class="token keyword">in</span> cute_strings<span class="token punctuation">:</span>
        m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s<span class="token punctuation">)</span>
        <span class="token keyword">if</span> m<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;match: {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;non match: {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="at-least-once"><a href="#at-least-once" class="header-anchor">#</a> At least once</h4> <p>If I want to match all strings that containt <strong>at least</strong> one &quot;w&quot;, we can use the character <code>+</code>. A <code>+</code> means that we want to find <strong>one or more repetitions</strong> of whatever was to the left of it. For example, the regex <code>a+</code> will match any string that has at least one &quot;a&quot;.</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;aw+&quot;</span>
match_cute_strings<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>match: awww
match: awwww
match: awwwwwww
match: awwwwwwwwwwwwwwww
match: aw
non match: a
</code></pre></div><h4 id="any-number-of-times"><a href="#any-number-of-times" class="header-anchor">#</a> Any number of times</h4> <p>If I want to match all strings that contain an arbitrary number of letters &quot;w&quot;, I can use the character <code>*</code>. The character <code>*</code> means <strong>match any number of repetitions</strong> of whatever comes on the left of it, <em>even 0 repetitions</em>! So the regex <code>a*</code> would match the empty string &quot;&quot;, because the empty string &quot;&quot; has 0 repetitions of the letter &quot;a&quot;.</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;aw*&quot;</span>
match_cute_strings<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>match: awww
match: awwww
match: awwwwwww
match: awwwwwwwwwwwwwwww
match: aw
match: a
</code></pre></div><h4 id="a-specific-number-of-times"><a href="#a-specific-number-of-times" class="header-anchor">#</a> A specific number of times</h4> <p>If I want to match a string that contains a certain particle a specific number of times, I can use the <code>{n}</code> notation, where <code>n</code> is replaced by the number of repetitions I want. For example, <code>a{3}</code> matches the string &quot;aaa&quot; but not the string &quot;aa&quot;.</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;aw{3}&quot;</span>
match_cute_strings<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>match: awww
match: awwww
match: awwwwwww
match: awwwwwwwwwwwwwwww
non match: aw
non match: a
</code></pre></div><p><strong>Wait a minute</strong>, why did the pattern <code>aw{3}</code> match the longer expressions of cuteness, like &quot;awwww&quot; or &quot;awwwwwww&quot;? Because the regular expressions try to find <em>substrings</em> that match the pattern. Our pattern is <code>awww</code> (if I write the <code>w{3}</code> explicitly) and the string <strong>awww</strong>w has that substring, just like the string <strong>awww</strong>wwww has it, or the longer version with 16 letters &quot;w&quot;. If we wanted to exclude the strings &quot;awwww&quot;, &quot;awwwwwww&quot; and &quot;awwwwwwwwwwwwwwww&quot; we would have to fix our regex. A better example that demonstrates how <code>{n}</code> works is by considering, instead of expressions of cuteness, expressions of amusement like &quot;wow&quot;, &quot;woow&quot; and &quot;wooooooooooooow&quot;. We define some expressions of amusement:</p> <ul><li>&quot;wow&quot;</li> <li>&quot;woow&quot;</li> <li>&quot;wooow&quot;</li> <li>&quot;woooow&quot;</li> <li>&quot;wooooooooow&quot;</li></ul> <p>and now we test our <code>{3}</code> pattern.</p> <div class="language-python extra-class"><pre class="language-python"><code>wow_strings <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;wow&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;woow&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;wooow&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;woooow&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;wooooooooow&quot;</span>
<span class="token punctuation">]</span>

<span class="token keyword">def</span> <span class="token function">match_wow_strings</span><span class="token punctuation">(</span>regex<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">&quot;&quot;&quot;Takes a regex, prints matches and non-matches&quot;&quot;&quot;</span>
    <span class="token keyword">for</span> s <span class="token keyword">in</span> wow_strings<span class="token punctuation">:</span>
        m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s<span class="token punctuation">)</span>
        <span class="token keyword">if</span> m<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;match: {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;non match: {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;wo{3}w&quot;</span>
match_wow_strings<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>non match: wow
non match: woow
match: wooow
non match: woooow
non match: wooooooooow
</code></pre></div><h4 id="between-n-and-m-times"><a href="#between-n-and-m-times" class="header-anchor">#</a> Between $n$ and $m$ times</h4> <p>Expressing amusement with only three &quot;o&quot; is ok, but people might also use two or four &quot;o&quot;. How can we capture a variable number of letters, but within a range? Say I only want to capture versions of &quot;wow&quot; that have between 2 and 4 letters &quot;o&quot;. I can do it with <code>{2,4}</code>.</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;wo{2,4}w&quot;</span>
match_wow_strings<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>non match: wow
match: woow
match: wooow
match: woooow
non match: wooooooooow
</code></pre></div><h4 id="up-to-n-times-or-at-least-m-times"><a href="#up-to-n-times-or-at-least-m-times" class="header-anchor">#</a> Up to $n$ times or at least $m$ times</h4> <p>Now we are just playing with the type of repetitions we might want, but of course we might say that we want <strong>no more</strong> than $n$ repetitions, which you would do with <code>{,n}</code>, or that we want <strong>at least</strong> $m$ repetitions, which you would do with <code>{m,}</code>.</p> <p>In fact, take a look at these regular expressions:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;wo{,4}w&quot;</span> <span class="token comment"># should not match strings with more than 4 o's</span>
match_wow_strings<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>match: wow
match: woow
match: wooow
match: woooow
non match: wooooooooow
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;wo{3,}w&quot;</span> <span class="token comment"># should not match strings with less than 3 o's</span>
match_wow_strings<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>non match: wow
non match: woow
match: wooow
match: woooow
match: wooooooooow
</code></pre></div><h4 id="to-be-or-not-to-be"><a href="#to-be-or-not-to-be" class="header-anchor">#</a> To be or not to be</h4> <p>Last but not least, sometimes we care about something that might or might not be present. For example, above we dealed with the English and Italian versions of the name Virgilio. If we wanted to write a regular expression to capture both versions, we could write <code>((V|v)irgil)|((V|v)irgilio)</code>, or slightly more compact, <code>(V|v)((irgil)|(irgilio))</code>. But this does not look good at all, right? All we need to say is that the final &quot;io&quot; might or might not be present. We do this with the <code>?</code> character. So the regex <code>(V|v)irgil(io)?</code> matches the upper and lower case versions of &quot;Virgil&quot; and &quot;Virgilio&quot;.</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;(V|v)irgil(io)?&quot;</span>
names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;virgil&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Virgil&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;virgilio&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Virgilio&quot;</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> name <span class="token keyword">in</span> names<span class="token punctuation">:</span>
    m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    <span class="token keyword">if</span> m<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;The name {} was matched!&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>The name virgil was matched!
The name Virgil was matched!
The name virgilio was matched!
The name Virgilio was matched!
</code></pre></div><h3 id="greed"><a href="#greed" class="header-anchor">#</a> Greed</h3> <p>The <code>+</code>, <code>?</code>, <code>*</code> and <code>{,}</code> operators are all greedy. What does this mean? It means that they will try to match as much as possible. They have this default behaviour, as opposed to stopping to try and find more matches as soon as the regex is satisfied. To better illustrate what I mean by this, let us look again at the information contained in the <code>match</code> object we have been dealing with:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;a+&quot;</span>
s <span class="token operator">=</span> <span class="token string">&quot;aaa&quot;</span>
m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(0, 3), match='aaa'&gt;
</code></pre></div><p>Notice the part of the printed information that says <code>match='aaa'</code>. The function <code>m.group()</code> will let me know what was the actual string that was matched by the regular expression, and in this case it was &quot;aaa&quot;. Why does it make sense to have access to this information? Well, the regex I wrote, <code>a+</code>, will match one or more letters &quot;a&quot; in a row. If I use the regex over a string and I get a match, how would I be able to know how many &quot;a&quot;s were matched, if I didn't have access to that type of information?</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>aaa
</code></pre></div><p>So let us verify that, in fact, the operators I mentioned are all greedy. Again, because they all match as many characters as they can.</p> <p>Below, we see that given a string of thirty times the letter &quot;a&quot;,</p> <ul><li>the pattern <code>a?</code> matches 1 &quot;a&quot;, which is as much as it could</li> <li>the pattern <code>a+</code> matches 30 &quot;a&quot;s, which is as much as it could</li> <li>the pattern <code>a*</code> also matches 30</li> <li>the pattern <code>a{5,10}</code> matches 10 &quot;a&quot;s, which was the limit imposed by us</li></ul> <div class="language-python extra-class"><pre class="language-python"><code>s <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token operator">*</span><span class="token number">30</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">&quot;a?&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">&quot;a+&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">&quot;a*&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">&quot;a{5,10}&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>a
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaa
</code></pre></div><p>If we don't want our operators to be greedy, we just put an extra <code>?</code> after them. So the following regular expressions are <strong>not</strong> greedy:</p> <ul><li>the pattern <code>a??</code> will match <strong>no</strong> characters, much like <code>a*?</code>, because now their goal is to match as little as possible. But a match of length 0 is the shortest match possible!</li> <li>the pattern <code>a+?</code> will only match 1 &quot;a&quot;</li> <li>the pattern <code>a{5,10}?</code> will only match 5 &quot;a&quot;s</li></ul> <p>We can easily confirm what I just said by running the code below. Notice that now I print things differently, because otherwise we wouldn't be able to see the <code>a??</code> and <code>a*?</code> patterns matching nothing.</p> <div class="language-python extra-class"><pre class="language-python"><code>s <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token operator">*</span><span class="token number">30</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;'{}'&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">&quot;a??&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;'{}'&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">&quot;a+?&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;'{}'&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">&quot;a*?&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;'{}'&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">&quot;a{5,10}?&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>''
'a'
''
'aaaaa'
</code></pre></div><h3 id="removing-excessive-spaces"><a href="#removing-excessive-spaces" class="header-anchor">#</a> Removing excessive spaces</h3> <p>Now that we know about repetitions, I am going to tell you about the <code>sub</code> function and we are going to use that to parse a piece of text and remove all extra spaces that are present. Typing in <code>re.sub(regex, rep, string)</code> will use the given regex on the given string, and whenever it matches, it removes the match and puts the <code>rep</code> in there.</p> <p>For example, I can use that to replace all English/Italian occurrences of the name Virgilio with a standardized one:</p> <div class="language-python extra-class"><pre class="language-python"><code>s <span class="token operator">=</span> <span class="token string">&quot;Virgilio has many names, like virgil, virgilio, Virgil, Vergil, or even vergil.&quot;</span>
regex <span class="token operator">=</span> <span class="token string">&quot;(V|v)(e|i)rgil(io)?&quot;</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>
    re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;Virgilio&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>Virgilio has many names, like Virgilio, Virgilio, Virgilio, Virgilio, or even Virgilio.


Now   it  is your   turn.  I am     going  to give   you this    sentence as        input, and   your  job    is to      fix the     whitespace         in it. When you    are  done,    save the    result in a  string  named   `s`, and   check    if  `s.count(&quot;  &quot;)` is   equal   to    0  or not.
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code>weird_text <span class="token operator">=</span> <span class="token string">&quot;Now   it  is your   turn.  I am     going  to give   you this    sentence as        input, and   your  job    is to      fix the     whitespace         in it. When you    are  done,    save the    result in a  string  named   `s`, and   check    if  `s.count(&quot;</span>  <span class="token string">&quot;)` is   equal   to    0  or not.&quot;</span>
regex <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>  <span class="token comment"># put your regex here</span>

<span class="token comment"># substitute the extra whitespace here</span>
<span class="token comment"># save the result in 's'</span>

<span class="token comment"># this print should be 0</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">&quot;  &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="character-classes"><a href="#character-classes" class="header-anchor">#</a> Character classes</h2> <p>So far we have been using writing some simple regular expressions that have been matching some words, and some names, and things like that. Now we have a different plan. We will write a regular expression that will match on US phone numbers, which we will assume are of the form xxx-xxx-xxxx. The first three digits are the area code, but we will not care about whether the area code actually makes sense or not. How do we match this, then?</p> <p>In fact, how can I match the first digit? It can be any number from 0 to 9, so should I write <code>(0|1|2|3|4|5|6|7|8|9)</code> to match the first digit, and then repeat? Actually, we could do that, yes, to get this regex:</p> <p><code>(0|1|2|3|4|5|6|7|8|9){3}-(0|1|2|3|4|5|6|7|8|9){3}-(0|1|2|3|4|5|6|7|8|9){4}</code></p> <p>Does this work?</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;(0|1|2|3|4|5|6|7|8|9){3}-(0|1|2|3|4|5|6|7|8|9){3}-(0|1|2|3|4|5|6|7|8|9){4}&quot;</span>
numbers <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;202-555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;202555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;202 555 0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;512-555-0191&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;96-125-3546&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
<span class="token keyword">for</span> nr <span class="token keyword">in</span> numbers<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> nr<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(0, 12), match='202-555-0181'&gt;
None
None
&lt;re.Match object; span=(0, 12), match='512-555-0191'&gt;
None
</code></pre></div><p>It looks like it works, but surely there must be a better way... and there is! Instead of writing out every digit like we did, we can actually write a range of values! In fact, the regex <code>[0-9]</code> matches all digits from 0 to 9. So we can actually shorten our regex to <code>[0-9]{3}-[0-9]{3}-[0-9]{4}</code>:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;[0-9]{3}-[0-9]{3}-[0-9]{4}&quot;</span>
numbers <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;202-555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;202555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;202 555 0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;512-555-0191&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;96-125-3546&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
<span class="token keyword">for</span> nr <span class="token keyword">in</span> numbers<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> nr<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(0, 12), match='202-555-0181'&gt;
None
None
&lt;re.Match object; span=(0, 12), match='512-555-0191'&gt;
None
</code></pre></div><p>The magic here is being done by the <code>[]</code>, which denotes a character class. The way <code>[]</code> works is, the regex will try to match any of the things that are inside, and it just so happens that <code>0-9</code> is a shorter way of listing all the digits. Of course you could also do <code>[0123456789]{3}-[0123456789]{3}-[0123456789]{4}</code> which is slightly shorter than our first attempt, but still pretty bad. Similar to <code>0-9</code>, we have <code>a-z</code> and <code>A-Z</code>, which go through all letters of the alphabet.</p> <p>You can also start and end in different places, for example <code>c-o</code> can be used to match words that only use letters between the &quot;c&quot; and the &quot;o&quot;, like &quot;hello&quot;:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;[c-o]+&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;rice&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(0, 5), match='hello'&gt;
&lt;re.Match object; span=(1, 4), match='ice'&gt;
</code></pre></div><p>With these character classes we can actually rewrite our Virgilio regex into something slightly shorter, going from <code>(V|v)(e|i)rgil(io)?</code> to <code>[Vv][ie]rgil(io)?</code>.</p> <div class="language-python extra-class"><pre class="language-python"><code>s <span class="token operator">=</span> <span class="token string">&quot;Virgilio has many names, like virgil, virgilio, Virgil, Vergil, or even vergil.&quot;</span>
regex <span class="token operator">=</span> <span class="token string">&quot;[Vv][ie]rgil(io)?&quot;</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>
    re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;Virgilio&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>Virgilio has many names, like Virgilio, Virgilio, Virgilio, Virgilio, or even Virgilio.
</code></pre></div><p>Again we see that our regular expression matched the <strong>ice</strong> in r<strong>ice</strong>, because the &quot;r&quot; was not inside the legal range of letters, but <strong>ice</strong> was.</p> <p>The <em>character class</em> is the square brackets <code>[]</code> and whatever goes inside it. Also, note that the special characters we have been using lose their meaning inside a character class! So <code>[()?+*{}]</code> will actually look to match any of those characters:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;[()?+*{}]&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;Did I just ask a question?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(25, 26), match='?'&gt;
</code></pre></div><p>A final note on character classes, if they start with <code>^</code> then we are actually saying &quot;use everything <em>except</em> what is inside this&quot;:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;[^c-o]+&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;rice&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>None
&lt;re.Match object; span=(0, 1), match='r'&gt;
</code></pre></div><h3 id="phone-numbers-v1"><a href="#phone-numbers-v1" class="header-anchor">#</a> Phone numbers v1</h3> <p>Now that you know how to use character classes to denote ranges, you need to write a regular expression that matches american phone numbers with the format xxx-xxx-xxxx. Not only that, but you must also cope with the fact that the numbers may or may not be preceeded by the country indicator, which you can assume that will look like &quot;+1&quot; or &quot;001&quot;. The country indicator may be separated from the rest of the number with a space or with a dash.</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>  <span class="token comment"># write your regex here</span>
matches <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token comment"># you should be able to match those</span>
    <span class="token string">&quot;202-555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;001 202-555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;+1-512-555-0191&quot;</span>
<span class="token punctuation">]</span>
non_matches <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token comment"># for now, none of these should be matched</span>
    <span class="token string">&quot;202555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;96-125-3546&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;(+1)5125550191&quot;</span>
<span class="token punctuation">]</span>
<span class="token keyword">for</span> s <span class="token keyword">in</span> matches<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> s <span class="token keyword">in</span> non_matches<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="more-re-functions"><a href="#more-re-functions" class="header-anchor">#</a> More <code>re</code> functions</h2> <p>So far we only looked at the <code>.search()</code> function of the <code>re</code> module, but now I am going to tell you about a couple more function that can be quite handy when you are dealing with pattern matching. By the time you are done with this small section, you will now the following functions: <code>match()</code>, <code>search()</code>, <code>findall()</code>, <code>sub()</code> and <code>split()</code>.</p> <p>If you are here mostly for the regular expressions, and you don't care much about using them with Python, you can just skim through this section... even though it is still a nice read.</p> <h4 id="search-and-sub"><a href="#search-and-sub" class="header-anchor">#</a> <code>search()</code> and <code>sub()</code></h4> <p>You already know these two functions, <code>re.search(regex, string)</code> will try to find your pattern given by <code>regex</code> in the given <code>string</code> and return the information of the match in a <code>match</code> object. The function <code>re.sub(regex, rep, string)</code> will take a regex and two strings; it will then look for the pattern you specified in <code>string</code> and replace the matches with the other string <code>rep</code> you gave it.</p> <h4 id="match"><a href="#match" class="header-anchor">#</a> <code>match()</code></h4> <p>The function <code>re.match(regex, string)</code> is similar to the function <code>re.search()</code>, except that <code>.match()</code> will only check if your pattern applies to the <strong>beginning</strong> of the string. That is, if your string does not <strong>start</strong> with the pattern you provided, the function returns <code>None</code>.</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;abc&quot;</span>
string1 <span class="token operator">=</span> <span class="token string">&quot;abcdef&quot;</span>
string2 <span class="token operator">=</span> <span class="token string">&quot;the alphabet starts with abc&quot;</span>
<span class="token comment"># the .search() function finds the patterns, regardless of position</span>
<span class="token keyword">if</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string1<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;.search() found {} in {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string1<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;.search() found {} in {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string2<span class="token punctuation">)</span><span class="token punctuation">)</span>
    
<span class="token comment"># the .match() function only checks if the string STARTS with the pattern</span>
<span class="token keyword">if</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string1<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;.match() says that {} starts with {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>string1<span class="token punctuation">,</span> regex<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string2<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># this one should NOT print</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;.match() says that {} starts with {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>string2<span class="token punctuation">,</span> regex<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>.search() found abc in abcdef
.search() found abc in the alphabet starts with abc
.match() says that abcdef starts with abc
</code></pre></div><h4 id="findall"><a href="#findall" class="header-anchor">#</a> <code>findall()</code></h4> <p>The <code>re.findall(regex, string)</code> is exactly like the <code>.search()</code> function, except that it will return <strong>all</strong> the matches it can find, instead of just the first one. Instead of returning a <code>match</code> object, it just returns the string that matched.</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;wow&quot;</span>
string <span class="token operator">=</span> <span class="token string">&quot;wow wow wow!&quot;</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(0, 3), match='wow'&gt;
['wow', 'wow', 'wow']
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;ab[0-9]&quot;</span>
string <span class="token operator">=</span> <span class="token string">&quot;ab1 ab2 ab3&quot;</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(0, 3), match='ab1'&gt;
['ab1', 'ab2', 'ab3']
</code></pre></div><p>It is important to note that the <code>findall()</code> function only returns <em>non-overlaping</em> matches. That is, one could argue that <code>wow</code> appears twice in &quot;wowow&quot;, in the beginning: <strong>wow</strong>ow, and in the end: wo<strong>wow</strong>. Nonetheless, <code>findall()</code> only returns one match because the second match overlaps with the first:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;wow&quot;</span>
string <span class="token operator">=</span> <span class="token string">&quot;wowow&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>['wow']
</code></pre></div><p>With this information it now makes a bit more sense to consider the greediness of the operators we showed before, like <code>?</code> and <code>+</code>. Imagine we are dealing with the regex <code>a+</code> and we have a string &quot;aaaaaaaaa&quot;. If we use the greedy version of <code>+</code>, then we get a single match which is the whole string. If we use the non-greedy version of the operator <code>+</code>, perhaps because we want as many matches as possible, we will get a bunch of &quot;a&quot; matches!</p> <div class="language-python extra-class"><pre class="language-python"><code>regex_greedy <span class="token operator">=</span> <span class="token string">&quot;a+&quot;</span>
regex_nongreedy <span class="token operator">=</span> <span class="token string">&quot;a+?&quot;</span>
string <span class="token operator">=</span> <span class="token string">&quot;aaaaaaaaa&quot;</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>regex_greedy<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>regex_nongreedy<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>['aaaaaaaaa']
['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a']
</code></pre></div><h4 id="split"><a href="#split" class="header-anchor">#</a> <code>split()</code></h4> <p>The <code>re.split(regex, string)</code> splits the given string into bits wherever it is able to find the pattern you specified. Say we are interested in finding all the sequences of consecutive consonants in a sentence (I don't know why you would want that...). Then we can use the vowels and the space &quot; &quot; to break up the sentence:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;[aeiou ]+&quot;</span> <span class="token comment"># this will eliminate all vowels/spaces that appear consecutively</span>
string <span class="token operator">=</span> <span class="token string">&quot;This is just a regular sentence&quot;</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>['Th', 's', 's', 'j', 'st', 'r', 'g', 'l', 'r', 's', 'nt', 'nc', '']
</code></pre></div><h3 id="search-with-match"><a href="#search-with-match" class="header-anchor">#</a> <code>search</code> with <code>match</code></h3> <p>Recall that the <code>match()</code> function only checks if your pattern is in the beginning of the string. What I want you to do is define your own <code>search</code> function that takes a regex and a string, and returns <code>True</code> if the pattern is inside the string, and <code>False</code> otherwise. Can you do it?</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">my_search</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>  <span class="token comment"># write your code here</span>

regex <span class="token operator">=</span> <span class="token string">&quot;[0-9]{2,4}&quot;</span>

<span class="token comment"># your function should be able to match in all these strings</span>
string1 <span class="token operator">=</span> <span class="token string">&quot;1984 was already some years ago.&quot;</span>
string2 <span class="token operator">=</span> <span class="token string">&quot;There is also a book whose title is '1984', but the story isn't set in the year of 1984.&quot;</span>
string3 <span class="token operator">=</span> <span class="token string">&quot;Sometimes people write '84 for short.&quot;</span>

<span class="token comment"># your function should also match with this regex and this string</span>
regex <span class="token operator">=</span> <span class="token string">&quot;a*&quot;</span>
string <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>
</code></pre></div><h3 id="count-matches-with-findall"><a href="#count-matches-with-findall" class="header-anchor">#</a> Count matches with <code>findall</code></h3> <p>Now I want you to define the <code>count_matches</code> function, which takes a regex and a string, and returns the number of non-overlaping matches there exist in the given string. Can you do it?</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">count_matches</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>  <span class="token comment"># your code goes here</span>

regex <span class="token operator">=</span> <span class="token string">&quot;wow&quot;</span>

string1 <span class="token operator">=</span> <span class="token string">&quot;wow wow wow&quot;</span> <span class="token comment"># this should be 3</span>
string2 <span class="token operator">=</span> <span class="token string">&quot;wowow&quot;</span> <span class="token comment"># this should be 1</span>
string3 <span class="token operator">=</span> <span class="token string">&quot;wowowow&quot;</span> <span class="token comment"># this should be 2</span>
</code></pre></div><h2 id="special-characters"><a href="#special-characters" class="header-anchor">#</a> Special characters</h2> <p>It is time to ramp things up a bit! We have seen some characters that have special meanings, and now I am going to introduce a couple more of those! I will start by listing them, and then I'll explain them in more detail:</p> <ul><li><code>.</code> is used to match <strong>any</strong> character, except for a newline</li> <li><code>^</code> is used to match at the beginning of the string</li> <li><code>$</code> is used to match at the end of the string</li> <li><code>\d</code> is used to match any digit</li> <li><code>\w</code> is used to match any alphanumeric character</li> <li><code>\s</code> is used to match any type of whitespace</li> <li><code>\</code> is used to remove the special meaning of the characters</li></ul> <h4 id="dot"><a href="#dot" class="header-anchor">#</a> Dot <code>.</code></h4> <p>The <code>.</code> can be used in a regular expression to capture any character that might have been used there, as long as we are still in the same line. That is, the only place where <code>.</code> doesn't work is if we changed lines in the text. Imagine the pattern was <code>d.ck</code>. Then the pattern would match</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;duck&quot;```

but it would not match

</code></pre></div><p>&quot;d
ck&quot;```</p> <p>because we changed lines in the middle of the string.</p> <h4 id="caret"><a href="#caret" class="header-anchor">#</a> Caret <code>^</code></h4> <p>If we use a <code>^</code> in the beginning of the regular expression, then we only care about matches in the beginning of the string. That is, <code>^wow</code> would only match if the string started with &quot;wow&quot;:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;^wow&quot;</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;wow, this is awesome&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;this is awesome, wow&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(0, 3), match='wow'&gt;
None
</code></pre></div><p>Recall that <code>^</code> inside the character class can also mean &quot;anything but whatever is in this class&quot;, so the regular expression <code>[^d]uck</code> would match any string that has <strong>uck</strong> in it, as long as it is not the word &quot;duck&quot;. If the caret <code>^</code> appears inside a character class <code>[]</code> but it is not the first character, than it has no special meaning and it just stands for the character itself. This means that the regex <code>[()^{}]</code> is looking to match any of the characters listed:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;[()^{}]&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;^&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;(&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(0, 1), match='^'&gt;
&lt;re.Match object; span=(0, 1), match='('&gt;
&lt;re.Match object; span=(0, 1), match='}'&gt;
</code></pre></div><h4 id="dollar-sign"><a href="#dollar-sign" class="header-anchor">#</a> Dollar sign <code>$</code></h4> <p>Contrary to the caret <code>^</code>, the dollar sign only matches at the end of the string!</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;wow$&quot;</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;wow, this is awesome&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;this is awesome, wow&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>None
&lt;re.Match object; span=(17, 20), match='wow'&gt;
</code></pre></div><p>Combining the <code>^</code> with the <code>$</code> means we are looking to match the whole string with our pattern. For example <code>^[a-zA-Z ]*$</code> checks if our string only contains letters and spaces and nothing else:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;^[a-zA-Z ]*$&quot;</span>

s1 <span class="token operator">=</span> <span class="token string">&quot;this is a sentence with only letters and spaces&quot;</span>
s2 <span class="token operator">=</span> <span class="token string">&quot;this sentence has 1 number&quot;</span>
s3 <span class="token operator">=</span> <span class="token string">&quot;this one has punctuation...&quot;</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s3<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(0, 47), match='this is a sentence with only letters and spaces'&gt;
None
None
</code></pre></div><h4 id="character-groups-d-w-and-s"><a href="#character-groups-d-w-and-s" class="header-anchor">#</a> Character groups <code>\d</code>, <code>\w</code> and <code>\s</code></h4> <p>Whenever you see a backslash followed by a letter, that probably means that something <em>special</em> is going on. These three special &quot;characters&quot; are shorthand notation for some character classes <code>[]</code>. For example, the <code>\d</code> is the same as <code>[0-9]</code>. The <code>\w</code> represents any alphanumeric character (like letters, numbers and <code>_</code>), and <code>\s</code> represents any whitespace character (like the space &quot; &quot;, the tab, the newline, etc).</p> <p>All these three special characters I showed, can be capitalized. If they are, then they mean the exact opposite! So <code>\D</code> means &quot;anything <strong>except</strong> a digit&quot;, <code>\W</code> means &quot;anything <strong>except</strong> an alphanumeric character&quot; and <code>\S</code> means &quot;anything <strong>except</strong> whitespace characters.</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;\D+&quot;</span>
s <span class="token operator">=</span> <span class="token string">&quot;these are some words&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>['these are some words']
</code></pre></div><p>Adding up to that, these special characters can be used inside a character class, so for instance <code>[abc\d]</code> would match any digit and the letters &quot;a&quot;, &quot;b&quot; and &quot;c&quot;. If the caret character <code>^</code> is used, then we are excluding whatever the special character refers to. As an example, if <code>[\d]</code> would match any digit, then <code>[^\d]</code> will match anything that is not a digit.</p> <h4 id="the-backslash"><a href="#the-backslash" class="header-anchor">#</a> The backslash <code>\</code></h4> <p>We already saw the backslash being used before letters to give them some special meaning... Well, the backslash before a special character also strips it of its special meaning! So, if you wanted to match a backslash, you could use <code>\\</code>. If you want to match any of the other special characters we already saw, you could put a <code>\</code> before them, like <code>\+</code> to match a plus sign. The next regular expression can be used to match an addition expression like &quot;16 + 6&quot;</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;[\d]+ ?\+ ?[\d]+&quot;</span>
add1 <span class="token operator">=</span> <span class="token string">&quot;16 + 6&quot;</span>
add2 <span class="token operator">=</span> <span class="token string">&quot;4325+2&quot;</span>
add3 <span class="token operator">=</span> <span class="token string">&quot;4+ 564&quot;</span>
mult1 <span class="token operator">=</span> <span class="token string">&quot;56 * 2&quot;</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> add1<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> add2<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> add3<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> mult1<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(0, 6), match='16 + 6'&gt;
&lt;re.Match object; span=(0, 6), match='4325+2'&gt;
&lt;re.Match object; span=(0, 6), match='4+ 564'&gt;
None
</code></pre></div><h3 id="phone-numbers-v2"><a href="#phone-numbers-v2" class="header-anchor">#</a> Phone numbers v2</h3> <p>Now I invite you to take a look at <a href="#Phone-numbers-v1">Phone numbers v1</a> and rewrite your regular expression to include some new special characters that you didn't know before!</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>  <span class="token comment"># write your regex here</span>
matches <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token comment"># you should be able to match those</span>
    <span class="token string">&quot;202-555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;001 202-555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;+1-512-555-0191&quot;</span>
<span class="token punctuation">]</span>
non_matches <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token comment"># for now, none of these should be matched</span>
    <span class="token string">&quot;202555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;96-125-3546&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;(+1)5125550191&quot;</span>
<span class="token punctuation">]</span>
<span class="token keyword">for</span> s <span class="token keyword">in</span> matches<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> s <span class="token keyword">in</span> non_matches<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="groups"><a href="#groups" class="header-anchor">#</a> Groups</h2> <p>So far, when we used a regex to match a string we could retrieve the whole information of the match by using the <code>.group()</code> function on the match object:</p> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;my name? is&quot;</span>

m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot;my nam is Virgilio&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> m <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>my nam is
</code></pre></div><p>Say we are dealing with phone numbers again, and we want to look for phone numbers in a big text. But after that, we also want to extract the country from where the number is from. How could we do it..? Well, we can use a regex to match the phone numbers, and then use a second regex to extract the country code, right? (Let us just assume that phone numbers are written with the digits all in a sequence, with no spaces or &quot;-&quot; separating them.)</p> <div class="language-python extra-class"><pre class="language-python"><code>regex_number <span class="token operator">=</span> <span class="token string">&quot;((00|[+])\d{1,3}[ -])\d{8,12}&quot;</span>
regex_code <span class="token operator">=</span> <span class="token string">&quot;((00|[+])\d{1,3})&quot;</span>
matches <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token comment"># you should be able to match those</span>
    <span class="token string">&quot;+351 2025550181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;001 2025550181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;+1-5125550191&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;0048 123456789&quot;</span>
<span class="token punctuation">]</span>

<span class="token keyword">for</span> s <span class="token keyword">in</span> matches<span class="token punctuation">:</span>
    m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex_number<span class="token punctuation">,</span> s<span class="token punctuation">)</span>  <span class="token comment"># match the phone number</span>
    <span class="token keyword">if</span> m <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        phone_number <span class="token operator">=</span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># extract the phone number</span>
        code <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex_code<span class="token punctuation">,</span> phone_number<span class="token punctuation">)</span>  <span class="token comment"># match the country code</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;The country code is: {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>code<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>The country code is: +351
The country code is: 001
The country code is: +1
The country code is: 0048
</code></pre></div><p>But not only is this repetitive, because I just copied the beginning of the <code>regex_number</code> into the <code>regex_code</code>, but it becomes very cumbersome if I am trying to retrieve several different parts of my match. Because of this, there is a functionality of regular expressions that is <em>grouping</em>. By grouping parts of the regular expression, you can do things like using the repetition operators on them and <strong>retrieve their information</strong> later on.</p> <p>To do grouping, one only needs to use the <code>()</code> parenthesis. For example, the regex <code>(ab)+</code> looks for matches of the form &quot;ab&quot;, &quot;abab&quot;, &quot;ababab&quot;, etcetera.</p> <p>We also used the grouping <a href="#Matching-options">in the beginning</a> to create a regex that matched &quot;Virgilio&quot; and &quot;virgilio&quot;, by writing <code>(V|v)irgilio</code>.</p> <p>Now off to the part that really matters! We can use grouping to retrieve portions of the matches, and we do that with the <code>.group()</code> function! Any set of <code>()</code> defines a group, and then we can use the <code>.group(i)</code> function to retrieve group <code>i</code>. Just note that the 0th group is always the whole match, and then you start counting from the left!</p> <div class="language-python extra-class"><pre class="language-python"><code>regex_with_grouping <span class="token operator">=</span> <span class="token string">&quot;(abc) (de(fg)hi)&quot;</span>
m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex_with_grouping<span class="token punctuation">,</span> <span class="token string">&quot;abc defghi jklm n opq&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>abc defghi
abc defghi
abc
defghi
fg
('abc', 'defghi', 'fg')
</code></pre></div><p>Notice that <code>match.group()</code> and <code>match.group(0)</code> are the same thing. Also note that the function <code>match.groups()</code> returns all the groups in a tuple!</p> <h3 id="phone-numbers-v3"><a href="#phone-numbers-v3" class="header-anchor">#</a> Phone numbers v3</h3> <p>Using what you learned so far, write a regex that matches phone numbers with different country codes. Assume the following:</p> <ul><li>The country code starts with either <code>00</code> or <code>+</code>, followed by one to three digits</li> <li>The phone number has length between 8 and 12</li> <li>The phone number and country code are separated by a space &quot; &quot; or by a hyphen &quot;-&quot;</li></ul> <p>Have your code look for phone numbers in the string I will provide next, and have it print the different country codes it finds.</p> <p>You might want to read what the exact behaviour of <code>re.findall()</code> is when the regex has groups in it. You can do that by checking the <a href="https://docs.python.org/3/library/re.html#re.findall" target="_blank" rel="noopener noreferrer">documentation of the <code>re</code> module<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <div class="language-python extra-class"><pre class="language-python"><code>paragraph <span class="token operator">=</span> <span class="token triple-quoted-string string">&quot;&quot;&quot;Hello, I am Virgilio and I am from Italy.
If phones were a thing when I was alive, my number would've probably been 0039 3123456789.
I would also love to get a house with 3 floors and something like +1 000 square meters.
Now that we are at it, I can also tell you that the number 0039 3135313531 would have suited Leo da Vinci very well...
And come to think of it, someone told me that Socrates had dibs on +30-2111112222&quot;&quot;&quot;</span>
<span class="token comment"># you should find 3 phone numbers</span>
<span class="token comment"># and you should not be fooled by the other numbers that show up in the text</span>
</code></pre></div><h2 id="toy-project-about-regex"><a href="#toy-project-about-regex" class="header-anchor">#</a> Toy project about regex</h2> <p>For the toy project, that is far from trivial, you are left with mimicking what <a href="http://mathspp.blogspot.com/2017/11/on-computing-all-patterns-matched-by.html" target="_blank" rel="noopener noreferrer">I did here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. If you follow that link, you will find a piece of code that takes a regular expression and then prints all the strings that the given regex would match.</p> <p>I'll just give you a couple of examples on how this works:</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">import</span> sys
sys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">&quot;./regex-bin&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">import</span> regexPrinter

<span class="token keyword">def</span> <span class="token function">get_iter</span><span class="token punctuation">(</span>regex<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> regexPrinter<span class="token punctuation">.</span>printRegex<span class="token punctuation">(</span>regex<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">printall</span><span class="token punctuation">(</span>regex<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> poss_match <span class="token keyword">in</span> get_iter<span class="token punctuation">(</span>regex<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>poss_match<span class="token punctuation">)</span>

regex <span class="token operator">=</span> <span class="token string">&quot;V|virgilio&quot;</span>
printall<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token operator">*</span><span class="token number">30</span><span class="token punctuation">)</span>
regex <span class="token operator">=</span> <span class="token string">&quot;wo+w&quot;</span>
printall<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token operator">*</span><span class="token number">30</span><span class="token punctuation">)</span>
<span class="token comment"># notice that for some reason, dumb me used {n:m} instead of {n,m}</span>
<span class="token comment"># also note that I only implemented {n,m}, and not {n,} nor {,m} nor {n}</span>
<span class="token comment"># also note that this does not support nor \d nor [0-9]</span>
regex <span class="token operator">=</span> <span class="token string">&quot;((00|[+])1[ -])?[0123456789]{3:3}&quot;</span>
printall<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
</code></pre></div><p>Note that the code is protected against infinite patterns, which are signaled with <code>...</code>.</p> <div class="language-python extra-class"><pre class="language-python"><code>printall<span class="token punctuation">(</span><span class="token string">&quot;this is infinite!+&quot;</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>this is infinite!
this is infinite!!
this is infinite!...!
</code></pre></div><p>If you are completely new to this sort of things, then this will look completely impossible... but it is not, because I am a normal person and I was able to do it! So if you really want you can also do it! In the link you have listed all the functionality I decided to include, which excluded <code>\d</code>, for example.</p> <p>I was only able to do this in the way I did because I had gone through some (not all) of the blog posts in <a href="https://ruslanspivak.com/lsbasi-part1/" target="_blank" rel="noopener noreferrer">this amazing series<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>Maybe you can implement a smaller subset of the features without too much trouble? The point of this is that you could only print the strings matched by a regex if you know how regular expressions work. Try starting with only implementing literal matching and the <code>|</code> and <code>?</code> operators. Can you now include grouping <code>()</code> so that <code>(ab)?</code> would work as expected? Can you add <code>[]</code>? What about <code>+</code> and <code>*</code>? Or maybe start with <code>{n,m}</code> and write <code>?</code>, <code>+</code> and <code>*</code> as <code>{0,1}</code>, <code>{1,}</code> and <code>{0,}</code> respectively.</p> <p>You can also postpone this project for a bit, and dig deeper into the world of regex. The next section contains some additional references and some websites with exercises to practice your new knowledge!</p> <h2 id="further-reading"><a href="#further-reading" class="header-anchor">#</a> Further reading</h2> <p>For regular expressions in Python, you can take a look at the <a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener noreferrer">documentation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> of the <code>re</code> module, as well as this <a href="https://docs.python.org/3/howto/regex.html" target="_blank" rel="noopener noreferrer">regex HOWTO<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>Some nice topics to follow up on this would include, but are not limited to:</p> <ul><li>Non capturing groups (and named groups for Python)</li> <li>Lookaheads (positive, negative, ...)</li> <li>Regex compilation and flags (for Python)</li> <li>Recursive regular expressions</li></ul> <p><a href="https://regexr.com/" target="_blank" rel="noopener noreferrer">This<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> interesting website (and <a href="https://regex101.com/" target="_blank" rel="noopener noreferrer">this one<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> as well) provides an interface for you to type regular expressions and see what they match in a text. The tool also gives you an explanation of what your regular expression is doing.</p> <hr> <p>I found some interesting websites with exercises on regular expressions. <a href="https://regexone.com/lesson/introduction_abcs" target="_blank" rel="noopener noreferrer">This one<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> has more &quot;basic&quot; exercises, each one of them preceeded by an explanation of whatever you will need to complete the exercise. I suggest you to go through them. <a href="https://www.hackerrank.com/domains/regex" target="_blank" rel="noopener noreferrer">Hackerrank<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> and <a href="http://play.inginf.units.it/#/" target="_blank" rel="noopener noreferrer">regexplay<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> also have some interesting exercises, but those require you to login in some way.</p> <hr> <p>If you enjoyed this guide and/or it was useful, consider leaving a star in the <a href="https://github.com/clone95/Virgilio" target="_blank" rel="noopener noreferrer">Virgilio repository<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> and sharing it with your friends!</p> <p>This was brought to you by the editor of the <a href="https://mathspp.blogspot.com" target="_blank" rel="noopener noreferrer">Mathspp Blog<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="https://github.com/RojerGS" target="_blank" rel="noopener noreferrer">RojerGS<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <h3 id="suggested-solutions"><a href="#suggested-solutions" class="header-anchor">#</a> Suggested solutions</h3> <h3 id="pi-lookup-solved"><a href="#pi-lookup-solved" class="header-anchor">#</a> $\pi$ lookup (solved)</h3> <div class="language-python extra-class"><pre class="language-python"><code>pifile <span class="token operator">=</span> <span class="token string">&quot;regex-bin/pi.txt&quot;</span>
regex <span class="token operator">=</span> <span class="token string">&quot;9876&quot;</span>  <span class="token comment"># define your regex to look your favourite number up</span>

<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>pifile<span class="token punctuation">,</span> <span class="token string">&quot;r&quot;</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    pistr <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># pistr is a string that contains 1M digits of pi</span>
    
<span class="token comment">## search for your number here</span>
m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> pistr<span class="token punctuation">)</span>
<span class="token keyword">if</span> m<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Found the number '{}' at positions {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> m<span class="token punctuation">.</span>span<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Sorry, the first million digits of pi can't help you with that...&quot;</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>Found the number '9876' at positions (4087, 4091)
</code></pre></div><h3 id="virgilio-or-virgil-solved"><a href="#virgilio-or-virgil-solved" class="header-anchor">#</a> Virgilio or Virgil? (solved)</h3> <div class="language-python extra-class"><pre class="language-python"><code>paragraphs <span class="token operator">=</span> \
<span class="token triple-quoted-string string">&quot;&quot;&quot;Publius Vergilius Maro (Classical Latin: [ˈpuː.blɪ.ʊs wɛrˈɡɪ.lɪ.ʊs ˈma.roː]; traditional dates October 15, 70 BC – September 21, 19 BC[1]), usually called virgilio or Vergil (/ˈvɜːrdʒɪl/) in English, was an ancient Roman poet of the Augustan period. He wrote three of the most famous poems in Latin literature: the Eclogues (or Bucolics), the Georgics, and the epic Aeneid. A number of minor poems, collected in the Appendix Vergiliana, are sometimes attributed to him.[2][3]

Virgilio is traditionally ranked as one of Rome's greatest poets. His Aeneid has been considered the national epic of ancient Rome since the time of its composition. Modeled after Homer's Iliad and Odyssey, the Aeneid follows the Trojan refugee Aeneas as he struggles to fulfill his destiny and reach Italy, where his descendants Romulus and Remus were to found the city of Rome. virgilio's work has had wide and deep influence on Western literature, most notably Dante's Divine Comedy, in which virgilio appears as Dante's guide through Hell and Purgatory.&quot;&quot;&quot;</span>

regex <span class="token operator">=</span> <span class="token string">&quot;(V|v)irgilio&quot;</span>
parsed_str <span class="token operator">=</span> paragraphs
m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> parsed_str<span class="token punctuation">)</span>
<span class="token keyword">while</span> m <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
    parsed_str <span class="token operator">=</span> parsed_str<span class="token punctuation">[</span><span class="token punctuation">:</span>m<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">&quot;Virgil&quot;</span> <span class="token operator">+</span> parsed_str<span class="token punctuation">[</span>m<span class="token punctuation">.</span>end<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
    m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> parsed_str<span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>parsed_str<span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>Publius Vergilius Maro (Classical Latin: [ˈpuː.blɪ.ʊs wɛrˈɡɪ.lɪ.ʊs ˈma.roː]; traditional dates October 15, 70 BC – September 21, 19 BC[1]), usually called Virgil or Vergil (/ˈvɜːrdʒɪl/) in English, was an ancient Roman poet of the Augustan period. He wrote three of the most famous poems in Latin literature: the Eclogues (or Bucolics), the Georgics, and the epic Aeneid. A number of minor poems, collected in the Appendix Vergiliana, are sometimes attributed to him.[2][3]

Virgil is traditionally ranked as one of Rome's greatest poets. His Aeneid has been considered the national epic of ancient Rome since the time of its composition. Modeled after Homer's Iliad and Odyssey, the Aeneid follows the Trojan refugee Aeneas as he struggles to fulfill his destiny and reach Italy, where his descendants Romulus and Remus were to found the city of Rome. Virgil's work has had wide and deep influence on Western literature, most notably Dante's Divine Comedy, in which Virgil appears as Dante's guide through Hell and Purgatory.
</code></pre></div><h3 id="removing-excessive-spaces-solved"><a href="#removing-excessive-spaces-solved" class="header-anchor">#</a> Removing excessive spaces (solved)</h3> <div class="language-python extra-class"><pre class="language-python"><code>weird_text <span class="token operator">=</span> <span class="token string">&quot;Now   it  is your   turn.  I am     going  to give   you this    sentence as        input, and   your  job    is to      fix the     whitespace         in it. When you    are  done,    save the    result in a  string  named   `s`, and   check    if  `s.count(&quot;</span>  <span class="token string">&quot;)` is   equal   to    0  or not.&quot;</span>
regex <span class="token operator">=</span> <span class="token string">&quot; +&quot;</span>  <span class="token comment"># put your regex here</span>
<span class="token comment"># there are several possible solutions, I chose this one</span>

<span class="token comment"># substitute the extra whitespace here</span>
s <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">,</span> weird_text<span class="token punctuation">)</span>

<span class="token comment"># this print should be 0</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">&quot;  &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>0
Now it is your turn. I am going to give you this sentence as input, and your job is to fix the whitespace in it. When you are done, save the result in a string named `s`, and check if `s.count()` is equal to 0 or not.
</code></pre></div><h3 id="phone-numbers-v1-solved"><a href="#phone-numbers-v1-solved" class="header-anchor">#</a> Phone numbers v1 (solved)</h3> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;((00|[+])1[ -])?[0-9]{3}-[0-9]{3}-[0-9]{4}&quot;</span>  <span class="token comment"># write your regex here</span>
matches <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token comment"># you should be able to match those</span>
    <span class="token string">&quot;202-555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;001 202-555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;+1-512-555-0191&quot;</span>
<span class="token punctuation">]</span>
non_matches <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token comment"># for now, none of these should be matched</span>
    <span class="token string">&quot;202555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;96-125-3546&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;(+1)5125550191&quot;</span>
<span class="token punctuation">]</span>
<span class="token keyword">for</span> s <span class="token keyword">in</span> matches<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> s <span class="token keyword">in</span> non_matches<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(0, 12), match='202-555-0181'&gt;
&lt;re.Match object; span=(0, 16), match='001 202-555-0181'&gt;
&lt;re.Match object; span=(0, 15), match='+1-512-555-0191'&gt;
None
None
None
</code></pre></div><h3 id="search-with-matched-solved"><a href="#search-with-matched-solved" class="header-anchor">#</a> <code>search</code> with <code>matched</code> (solved)</h3> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">my_search</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span>
    found <span class="token operator">=</span> <span class="token boolean">False</span>
    <span class="token keyword">while</span> string<span class="token punctuation">:</span>
        m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span>
        <span class="token keyword">if</span> m<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        string <span class="token operator">=</span> string<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
    <span class="token comment"># check if the pattern matches the empty string</span>
    <span class="token keyword">if</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>

regex <span class="token operator">=</span> <span class="token string">&quot;[0-9]{2,4}&quot;</span>

<span class="token comment"># your function should be able to match in all these strings</span>
string1 <span class="token operator">=</span> <span class="token string">&quot;1984 was already some years ago.&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>my_search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string1<span class="token punctuation">)</span><span class="token punctuation">)</span>
string2 <span class="token operator">=</span> <span class="token string">&quot;There is also a book whose title is '1984', but the story isn't set in the year of 1984.&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>my_search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string2<span class="token punctuation">)</span><span class="token punctuation">)</span>
string3 <span class="token operator">=</span> <span class="token string">&quot;Sometimes people write '84 for short.&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>my_search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string3<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># your function should also match with this regex and this string</span>
regex <span class="token operator">=</span> <span class="token string">&quot;a*&quot;</span>
string <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>my_search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>True
True
True
True
</code></pre></div><h3 id="count-matches-with-findall-solved"><a href="#count-matches-with-findall-solved" class="header-anchor">#</a> Count matches with <code>findall</code> (solved)</h3> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">count_matches</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">)</span>

regex <span class="token operator">=</span> <span class="token string">&quot;wow&quot;</span>

string1 <span class="token operator">=</span> <span class="token string">&quot;wow wow wow&quot;</span> <span class="token comment"># this should be 3</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>count_matches<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string1<span class="token punctuation">)</span><span class="token punctuation">)</span>
string2 <span class="token operator">=</span> <span class="token string">&quot;wowow&quot;</span> <span class="token comment"># this should be 1</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>count_matches<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string2<span class="token punctuation">)</span><span class="token punctuation">)</span>
string3 <span class="token operator">=</span> <span class="token string">&quot;wowowow&quot;</span> <span class="token comment"># this should be 2</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>count_matches<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> string3<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>3
1
2
</code></pre></div><h3 id="phone-numbers-v2-solved"><a href="#phone-numbers-v2-solved" class="header-anchor">#</a> Phone numbers v2 (solved)</h3> <div class="language-python extra-class"><pre class="language-python"><code>regex <span class="token operator">=</span> <span class="token string">&quot;((00|[+])1[ -])?\d{3}-\d{3}-\d{4}&quot;</span>  <span class="token comment"># write your regex here</span>
matches <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token comment"># you should be able to match those</span>
    <span class="token string">&quot;202-555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;001 202-555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;+1-512-555-0191&quot;</span>
<span class="token punctuation">]</span>
non_matches <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token comment"># for now, none of these should be matched</span>
    <span class="token string">&quot;202555-0181&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;96-125-3546&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;(+1)5125550191&quot;</span>
<span class="token punctuation">]</span>
<span class="token keyword">for</span> s <span class="token keyword">in</span> matches<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> s <span class="token keyword">in</span> non_matches<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>&lt;re.Match object; span=(0, 12), match='202-555-0181'&gt;
&lt;re.Match object; span=(0, 16), match='001 202-555-0181'&gt;
&lt;re.Match object; span=(0, 15), match='+1-512-555-0191'&gt;
None
None
None
</code></pre></div><h4 id="phone-numbers-v3-solved"><a href="#phone-numbers-v3-solved" class="header-anchor">#</a> Phone numbers v3 (solved)</h4> <p>For this &quot;problem&quot;, one thinks of using the <code>.findall()</code> function to look for all matches. When we do that, we don't get a list of the match objects, but instead a list with tuples, where each tuple has a specific group from our regex. This is the behaviour that is <a href="https://docs.python.org/3/library/re.html#re.findall" target="_blank" rel="noopener noreferrer">documented for the <code>re.findall()</code> function<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>This is fine, because we really only cared about the number code, and we can print it easily. If we wanted the match objects, then the alternative would be to use the <a href="https://docs.python.org/3/library/re.html#re.finditer" target="_blank" rel="noopener noreferrer"><code>re.finditer()</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> function.</p> <div class="language-python extra-class"><pre class="language-python"><code>paragraph <span class="token operator">=</span> <span class="token triple-quoted-string string">&quot;&quot;&quot;Hello, I am Virgilio and I am from Italy.
If phones were a thing when I was alive, my number would've probably been 0039 3123456789.
I would also love to get a house with 3 floors and something like +1 000 square meters.
Now that we are at it, I can also tell you that the number 0039 3135313531 would have suited Leo da Vinci very well...
And come to think of it, someone told me that Socrates had dibs on +30-2111112222&quot;&quot;&quot;</span>
<span class="token comment"># you should find 3 phone numbers</span>
<span class="token comment"># and you should not be fooled by the other numbers that show up in the text</span>

regex <span class="token operator">=</span> <span class="token string">&quot;((00|[+])\d{1,3})[ -]\d{8,12}&quot;</span>
ns <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> paragraph<span class="token punctuation">)</span>  <span class="token comment"># find numbers</span>
<span class="token keyword">for</span> n <span class="token keyword">in</span> ns<span class="token punctuation">:</span>
    <span class="token comment"># n is a tuple with the two groups our string has</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
    
<span class="token keyword">for</span> n <span class="token keyword">in</span> re<span class="token punctuation">.</span>finditer<span class="token punctuation">(</span>regex<span class="token punctuation">,</span> paragraph<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;The number '{}' has country code: {}&quot;</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language- extra-class"><pre><code>('0039', '00')
('0039', '00')
('+30', '+')
The number '0039 3123456789' has country code: 0039
The number '0039 3135313531' has country code: 0039
The number '+30-2111112222' has country code: +30
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Virgilio/inferno/tools/latex.html" class="prev">
        LaTex
      </a></span> <span class="next"><a href="/Virgilio/inferno/tools/wolfram-alpha.html">
        Wolfram Alpha
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Virgilio/assets/js/app.3bb05fb7.js" defer></script><script src="/Virgilio/assets/js/2.ce33443b.js" defer></script><script src="/Virgilio/assets/js/24.5e2c1541.js" defer></script>
  </body>
</html>
